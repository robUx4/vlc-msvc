From 6748755612a5ced06d8f308e2b2b58e2770c7a57 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Hugo=20Beauz=C3=A9e-Luyssen?= <hugo@beauzee.fr>
Date: Tue, 28 Apr 2015 14:23:31 +0200
Subject: [PATCH 72/99] contrib: taglib: Use an IOstream to read the file

---
 contrib/src/taglib/iostream.patch | 132 ++++++++++++++++++++++++++++++++++++++
 contrib/src/taglib/rules.mak      |   1 +
 2 files changed, 133 insertions(+)
 create mode 100644 contrib/src/taglib/iostream.patch

diff --git a/contrib/src/taglib/iostream.patch b/contrib/src/taglib/iostream.patch
new file mode 100644
index 0000000..f4fca2b
--- /dev/null
+++ b/contrib/src/taglib/iostream.patch
@@ -0,0 +1,132 @@
+diff --git a/taglib/fileref.cpp b/taglib/fileref.cpp
+index 2b5d5f2..04d9a56 100644
+--- a/taglib/fileref.cpp
++++ b/taglib/fileref.cpp
+@@ -80,7 +80,12 @@ FileRef::FileRef()
+ FileRef::FileRef(FileName fileName, bool readAudioProperties,
+                  AudioProperties::ReadStyle audioPropertiesStyle)
+ {
+-  d = new FileRefPrivate(create(fileName, readAudioProperties, audioPropertiesStyle));
++    d = new FileRefPrivate(create(fileName, readAudioProperties, audioPropertiesStyle));
++}
++
++FileRef::FileRef(IOStream* stream, bool readAudioProperties, AudioProperties::ReadStyle audioPropertiesStyle)
++{
++    d = new FileRefPrivate(create(stream, readAudioProperties, audioPropertiesStyle));
+ }
+ 
+ FileRef::FileRef(File *file)
+@@ -284,3 +289,77 @@ File *FileRef::create(FileName fileName, bool readAudioProperties,
+ 
+   return 0;
+ }
++
++File *FileRef::create(IOStream* ioStream, bool readAudioProperties, AudioProperties::ReadStyle audioPropertiesStyle)
++{
++    // Ok, this is really dumb for now, but it works for testing.
++
++    String ext;
++    {
++  #ifdef _WIN32
++
++      String s = ioStream->name().toString();
++
++  #else
++
++      String s = ioStream->name();
++
++   #endif
++
++      const int pos = s.rfind(".");
++      if(pos != -1)
++        ext = s.substr(pos + 1).upper();
++    }
++
++    // If this list is updated, the method defaultFileExtensions() should also be
++    // updated.  However at some point that list should be created at the same time
++    // that a default file type resolver is created.
++
++    if(!ext.isEmpty()) {
++      if(ext == "MP3")
++        return new MPEG::File(ioStream, ID3v2::FrameFactory::instance(), readAudioProperties, audioPropertiesStyle);
++      if(ext == "OGG")
++        return new Ogg::Vorbis::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "OGA") {
++        /* .oga can be any audio in the Ogg container. First try FLAC, then Vorbis. */
++        File *file = new Ogg::FLAC::File(ioStream, readAudioProperties, audioPropertiesStyle);
++        if (file->isValid())
++          return file;
++        delete file;
++        return new Ogg::Vorbis::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      }
++      if(ext == "FLAC")
++        return new FLAC::File(ioStream, ID3v2::FrameFactory::instance(), readAudioProperties, audioPropertiesStyle);
++      if(ext == "MPC")
++        return new MPC::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "WV")
++        return new WavPack::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "SPX")
++        return new Ogg::Speex::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "OPUS")
++        return new Ogg::Opus::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "TTA")
++        return new TrueAudio::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "M4A" || ext == "M4R" || ext == "M4B" || ext == "M4P" || ext == "MP4" || ext == "3G2")
++        return new MP4::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "WMA" || ext == "ASF")
++        return new ASF::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "AIF" || ext == "AIFF" || ext == "AFC" || ext == "AIFC")
++        return new RIFF::AIFF::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "WAV")
++        return new RIFF::WAV::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "APE")
++        return new APE::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      // module, nst and wow are possible but uncommon extensions
++      if(ext == "MOD" || ext == "MODULE" || ext == "NST" || ext == "WOW")
++        return new Mod::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "S3M")
++        return new S3M::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "IT")
++        return new IT::File(ioStream, readAudioProperties, audioPropertiesStyle);
++      if(ext == "XM")
++        return new XM::File(ioStream, readAudioProperties, audioPropertiesStyle);
++    }
++
++    return 0;
++}
+diff --git a/taglib/fileref.h b/taglib/fileref.h
+index 0f0c21a..3ba03af 100644
+--- a/taglib/fileref.h
++++ b/taglib/fileref.h
+@@ -128,6 +128,20 @@ namespace TagLib {
+                      audioPropertiesStyle = AudioProperties::Average);
+ 
+     /*!
++     * Create a FileRef from an opened \a IOStream.  If \a readAudioProperties is true then
++     * the audio properties will be read using \a audioPropertiesStyle.  If
++     * \a readAudioProperties is false then \a audioPropertiesStyle will be
++     * ignored.
++     *
++     * Also see the note in the class documentation about why you may not want to
++     * use this method in your application.
++     */
++    explicit FileRef(IOStream* stream,
++                     bool readAudioProperties = true,
++                     AudioProperties::ReadStyle
++                     audioPropertiesStyle = AudioProperties::Average);
++
++    /*!
+      * Contruct a FileRef using \a file.  The FileRef now takes ownership of the
+      * pointer and will delete the File when it passes out of scope.
+      */
+@@ -252,6 +266,10 @@ namespace TagLib {
+                         bool readAudioProperties = true,
+                         AudioProperties::ReadStyle audioPropertiesStyle = AudioProperties::Average);
+ 
++    static File *create(IOStream* ioStream,
++                        bool readAudioProperties = true,
++                        AudioProperties::ReadStyle audioPropertiesStyle = AudioProperties::Average);
++
+ 
+   private:
+     class FileRefPrivate;
diff --git a/contrib/src/taglib/rules.mak b/contrib/src/taglib/rules.mak
index a24369a..b0ab6c5 100644
--- a/contrib/src/taglib/rules.mak
+++ b/contrib/src/taglib/rules.mak
@@ -21,6 +21,7 @@ taglib: taglib-$(TAGLIB_VERSION).tar.gz .sum-taglib
 	$(UNPACK)
 	$(APPLY) $(SRC)/taglib/taglib-pc.patch
 	$(APPLY) $(SRC)/taglib/0002-Rewrote-ByteVector-replace-simpler.patch
+	$(APPLY) $(SRC)/taglib/iostream.patch
 	$(MOVE)
 
 .taglib: taglib toolchain.cmake
-- 
1.9.5.msysgit.0

