From 3dc9b132316ada4d2d7ef0577ec9c2735e621510 Mon Sep 17 00:00:00 2001
From: Steve Lhomme <robUx4@gmail.com>
Date: Wed, 12 Aug 2015 11:41:02 +0200
Subject: [PATCH 086/128] contrib: MSVC doesn't like the near fields in the
 libav code

---
 contrib/src/ffmpeg/near_field.patch | 183 ++++++++++++++++++++++++++++++++++++
 contrib/src/ffmpeg/rules.mak        |   1 +
 2 files changed, 184 insertions(+)
 create mode 100644 contrib/src/ffmpeg/near_field.patch

diff --git a/contrib/src/ffmpeg/near_field.patch b/contrib/src/ffmpeg/near_field.patch
new file mode 100644
index 0000000..911d2a0
--- /dev/null
+++ b/contrib/src/ffmpeg/near_field.patch
@@ -0,0 +1,183 @@
+diff --git a/libavcodec/jpegls.c b/libavcodec/jpegls.c
+index 19d461f..8b5556b 100644
+--- a/libavcodec/jpegls.c
++++ b/libavcodec/jpegls.c
+@@ -32,7 +32,7 @@ void ff_jpegls_init_state(JLSState *state)
+ {
+     int i;
+ 
+-    state->twonear = state->near * 2 + 1;
++    state->twonear = state->near_lossless * 2 + 1;
+     state->range   = (state->maxval + state->twonear - 1) / state->twonear + 1;
+ 
+     // QBPP = ceil(log2(RANGE))
+@@ -75,25 +75,25 @@ void ff_jpegls_reset_coding_parameters(JLSState *s, int reset_all)
+         factor = FFMIN(s->maxval, 4095) + 128 >> 8;
+ 
+         if (s->T1 == 0 || reset_all)
+-            s->T1 = iso_clip(factor * (basic_t1 - 2) + 2 + 3 * s->near,
+-                             s->near + 1, s->maxval);
++            s->T1 = iso_clip(factor * (basic_t1 - 2) + 2 + 3 * s->near_lossless,
++                             s->near_lossless + 1, s->maxval);
+         if (s->T2 == 0 || reset_all)
+-            s->T2 = iso_clip(factor * (basic_t2 - 3) + 3 + 5 * s->near,
++            s->T2 = iso_clip(factor * (basic_t2 - 3) + 3 + 5 * s->near_lossless,
+                              s->T1, s->maxval);
+         if (s->T3 == 0 || reset_all)
+-            s->T3 = iso_clip(factor * (basic_t3 - 4) + 4 + 7 * s->near,
++            s->T3 = iso_clip(factor * (basic_t3 - 4) + 4 + 7 * s->near_lossless,
+                              s->T2, s->maxval);
+     } else {
+         factor = 256 / (s->maxval + 1);
+ 
+         if (s->T1 == 0 || reset_all)
+-            s->T1 = iso_clip(FFMAX(2, basic_t1 / factor + 3 * s->near),
+-                             s->near + 1, s->maxval);
++            s->T1 = iso_clip(FFMAX(2, basic_t1 / factor + 3 * s->near_lossless),
++                             s->near_lossless + 1, s->maxval);
+         if (s->T2 == 0 || reset_all)
+-            s->T2 = iso_clip(FFMAX(3, basic_t2 / factor + 5 * s->near),
++            s->T2 = iso_clip(FFMAX(3, basic_t2 / factor + 5 * s->near_lossless),
+                              s->T1, s->maxval);
+         if (s->T3 == 0 || reset_all)
+-            s->T3 = iso_clip(FFMAX(4, basic_t3 / factor + 7 * s->near),
++            s->T3 = iso_clip(FFMAX(4, basic_t3 / factor + 7 * s->near_lossless),
+                              s->T2, s->maxval);
+     }
+ 
+diff --git a/libavcodec/jpegls.h b/libavcodec/jpegls.h
+index eae3943..98b73a4 100644
+--- a/libavcodec/jpegls.h
++++ b/libavcodec/jpegls.h
+@@ -39,7 +39,7 @@ typedef struct JLSState {
+     int T1, T2, T3;
+     int A[367], B[367], C[365], N[367];
+     int limit, reset, bpp, qbpp, maxval, range;
+-    int near, twonear;
++    int near_lossless, twonear;
+     int run_index[3];
+ } JLSState;
+ 
+@@ -64,11 +64,11 @@ static inline int ff_jpegls_quantize(JLSState *s, int v)
+             return -3;
+         if (v <= -s->T1)
+             return -2;
+-        if (v < -s->near)
++        if (v < -s->near_lossless)
+             return -1;
+         return 0;
+     } else {
+-        if (v <= s->near)
++        if (v <= s->near_lossless)
+             return 0;
+         if (v < s->T1)
+             return 1;
+diff --git a/libavcodec/jpeglsdec.c b/libavcodec/jpeglsdec.c
+index 3b93799..3c4bbc2 100644
+--- a/libavcodec/jpeglsdec.c
++++ b/libavcodec/jpeglsdec.c
+@@ -105,7 +105,7 @@ static inline int ls_get_code_regular(GetBitContext *gb, JLSState *state, int Q)
+         ret >>= 1;
+ 
+     /* for NEAR=0, k=0 and 2*B[Q] <= - N[Q] mapping is reversed */
+-    if (!state->near && !k && (2 * state->B[Q] <= -state->N[Q]))
++    if (!state->near_lossless && !k && (2 * state->B[Q] <= -state->N[Q]))
+         ret = -(ret + 1);
+ 
+     ret = ff_jpegls_update_state_regular(state, Q, ret);
+@@ -180,9 +180,9 @@ static inline void ls_decode_line(JLSState *state, MJpegDecodeContext *s,
+         D1 = Rb - Rc;
+         D2 = Rc - Ra;
+         /* run mode */
+-        if ((FFABS(D0) <= state->near) &&
+-            (FFABS(D1) <= state->near) &&
+-            (FFABS(D2) <= state->near)) {
++        if ((FFABS(D0) <= state->near_lossless) &&
++            (FFABS(D1) <= state->near_lossless) &&
++            (FFABS(D2) <= state->near_lossless)) {
+             int r;
+             int RItype;
+ 
+@@ -215,13 +215,13 @@ static inline void ls_decode_line(JLSState *state, MJpegDecodeContext *s,
+ 
+             /* decode run termination value */
+             Rb     = R(last, x);
+-            RItype = (FFABS(Ra - Rb) <= state->near) ? 1 : 0;
++            RItype = (FFABS(Ra - Rb) <= state->near_lossless) ? 1 : 0;
+             err    = ls_get_code_runterm(&s->gb, state, RItype,
+                                          ff_log2_run[state->run_index[comp]]);
+             if (state->run_index[comp])
+                 state->run_index[comp]--;
+ 
+-            if (state->near && RItype) {
++            if (state->near_lossless && RItype) {
+                 pred = Ra + err;
+             } else {
+                 if (Rb < Ra)
+@@ -255,10 +255,10 @@ static inline void ls_decode_line(JLSState *state, MJpegDecodeContext *s,
+             /* we have to do something more for near-lossless coding */
+             pred += err;
+         }
+-        if (state->near) {
+-            if (pred < -state->near)
++        if (state->near_lossless) {
++            if (pred < -state->near_lossless)
+                 pred += state->range * state->twonear;
+-            else if (pred > state->maxval + state->near)
++            else if (pred > state->maxval + state->near_lossless)
+                 pred -= state->range * state->twonear;
+             pred = av_clip(pred, 0, state->maxval);
+         }
+@@ -269,7 +269,7 @@ static inline void ls_decode_line(JLSState *state, MJpegDecodeContext *s,
+     }
+ }
+ 
+-int ff_jpegls_decode_picture(MJpegDecodeContext *s, int near,
++int ff_jpegls_decode_picture(MJpegDecodeContext *s, int near_lossless,
+                              int point_transform, int ilv)
+ {
+     int i, t = 0;
+@@ -289,7 +289,7 @@ int ff_jpegls_decode_picture(MJpegDecodeContext *s, int near,
+         return AVERROR(ENOMEM);
+     }
+     /* initialize JPEG-LS state from JPEG parameters */
+-    state->near   = near;
++    state->near_lossless   = near_lossless;
+     state->bpp    = (s->bits < 2) ? 2 : s->bits;
+     state->maxval = s->maxval;
+     state->T1     = s->t1;
+@@ -307,7 +307,7 @@ int ff_jpegls_decode_picture(MJpegDecodeContext *s, int near,
+     ff_dlog(s->avctx,
+             "JPEG-LS params: %ix%i NEAR=%i MV=%i T(%i,%i,%i) "
+             "RESET=%i, LIMIT=%i, qbpp=%i, RANGE=%i\n",
+-            s->width, s->height, state->near, state->maxval,
++            s->width, s->height, state->near_lossless, state->maxval,
+             state->T1, state->T2, state->T3,
+             state->reset, state->limit, state->qbpp, state->range);
+     ff_dlog(s->avctx, "JPEG params: ILV=%i Pt=%i BPP=%i, scan = %i\n",
+diff --git a/libavcodec/jpeglsdec.h b/libavcodec/jpeglsdec.h
+index d60a87b..79730af 100644
+--- a/libavcodec/jpeglsdec.h
++++ b/libavcodec/jpeglsdec.h
+@@ -36,7 +36,7 @@
+  */
+ int ff_jpegls_decode_lse(MJpegDecodeContext *s);
+ 
+-int ff_jpegls_decode_picture(MJpegDecodeContext *s, int near,
++int ff_jpegls_decode_picture(MJpegDecodeContext *s, int near_lossless,
+                              int point_transform, int ilv);
+ 
+ #endif /* AVCODEC_JPEGLSDEC_H */
+diff --git a/libavcodec/mjpegdec.h b/libavcodec/mjpegdec.h
+index aa4703a..cf30a27 100644
+--- a/libavcodec/mjpegdec.h
++++ b/libavcodec/mjpegdec.h
+@@ -66,7 +66,7 @@ typedef struct MJpegDecodeContext {
+     int bits;           /* bits per component */
+ 
+     int maxval;
+-    int near;         ///< near lossless bound (si 0 for lossless)
++    int near_lossless;         ///< near lossless bound (si 0 for lossless)
+     int t1,t2,t3;
+     int reset;        ///< context halfing intervall ?rename
+ 
diff --git a/contrib/src/ffmpeg/rules.mak b/contrib/src/ffmpeg/rules.mak
index 90ec15f..894af55 100644
--- a/contrib/src/ffmpeg/rules.mak
+++ b/contrib/src/ffmpeg/rules.mak
@@ -196,6 +196,7 @@ ffmpeg: ffmpeg-$(HASH).tar.xz .sum-ffmpeg
 	$(XZCAT) "$<" | (cd $@-$(HASH) && tar xv --strip-components=1)
 ifdef HAVE_VISUALSTUDIO
 	$(APPLY) $(SRC)/ffmpeg/msvc.patch
+	$(APPLY) $(SRC)/ffmpeg/near_field.patch
 endif
 	$(MOVE)
 
-- 
1.9.5.msysgit.1

