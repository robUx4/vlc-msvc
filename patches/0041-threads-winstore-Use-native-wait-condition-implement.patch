From 9e4cc58c1eba1b311ae03540ee67ed0f7e76d172 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Hugo=20Beauz=C3=A9e-Luyssen?= <hugo@beauzee.fr>
Date: Thu, 20 Nov 2014 13:07:07 +0100
Subject: [PATCH 41/75] threads: winstore: Use native wait condition
 implementation

---
 include/vlc_threads.h |  4 ++++
 src/win32/thread.c    | 59 +++++++++++++++++++++++++++++++++++++++++++--------
 2 files changed, 54 insertions(+), 9 deletions(-)

diff --git a/include/vlc_threads.h b/include/vlc_threads.h
index d3f021b..cccafd0 100644
--- a/include/vlc_threads.h
+++ b/include/vlc_threads.h
@@ -57,7 +57,11 @@ typedef struct
 #define VLC_STATIC_MUTEX { false, { { false, 0 } } }
 typedef struct
 {
+#ifndef VLC_WINSTORE_APP
     HANDLE   handle;
+#else
+    CONDITION_VARIABLE cond;
+#endif
     unsigned clock;
 } vlc_cond_t;
 #define VLC_STATIC_COND { 0, 0 }
diff --git a/src/win32/thread.c b/src/win32/thread.c
index cab973e..a141b0e 100644
--- a/src/win32/thread.c
+++ b/src/win32/thread.c
@@ -203,10 +203,14 @@ enum
 
 static void vlc_cond_init_common (vlc_cond_t *p_condvar, unsigned clock)
 {
+#ifndef VLC_WINSTORE_APP
     /* Create a manual-reset event (manual reset is needed for broadcast). */
     p_condvar->handle = CreateEvent (NULL, TRUE, FALSE, NULL);
     if (!p_condvar->handle)
         abort();
+#else
+    InitializeConditionVariable(&p_condvar->cond);
+#endif
     p_condvar->clock = clock;
 }
 
@@ -222,13 +226,22 @@ void vlc_cond_init_daytime (vlc_cond_t *p_condvar)
 
 void vlc_cond_destroy (vlc_cond_t *p_condvar)
 {
+#ifndef VLC_WINSTORE_APP
     CloseHandle (p_condvar->handle);
+#endif
 }
 
 void vlc_cond_signal (vlc_cond_t *p_condvar)
 {
+#ifndef VLC_WINSTORE_APP
     /* This is suboptimal but works. */
     vlc_cond_broadcast (p_condvar);
+#else
+    if (!p_condvar->clock)
+        return;
+
+    WakeConditionVariable(&p_condvar->cond);
+#endif
 }
 
 void vlc_cond_broadcast (vlc_cond_t *p_condvar)
@@ -236,36 +249,51 @@ void vlc_cond_broadcast (vlc_cond_t *p_condvar)
     if (!p_condvar->clock)
         return;
 
+#ifndef VLC_WINSTORE_APP
     /* Wake all threads up (as the event HANDLE has manual reset) */
     SetEvent (p_condvar->handle);
+#else
+    WakeAllConditionVariable(&p_condvar->cond);
+#endif
 }
 
 void vlc_cond_wait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex)
 {
-    DWORD result;
-
     if (!p_condvar->clock)
     {   /* FIXME FIXME FIXME */
-        msleep (50000);
+        msleep(50000);
         return;
     }
 
+    DWORD result;
+
     do
     {
         vlc_testcancel ();
-        vlc_mutex_unlock (p_mutex);
-        result = vlc_WaitForSingleObject (p_condvar->handle, INFINITE);
-        vlc_mutex_lock (p_mutex);
+#ifndef VLC_WINSTORE_APP
+        vlc_mutex_unlock(p_mutex);
+        result = vlc_WaitForSingleObject(p_condvar->handle, INFINITE);
+        vlc_mutex_lock(p_mutex);
+#else
+        if (SleepConditionVariableCS(&p_condvar->cond, &p_mutex->mutex, 50))
+            return;
+        result = GetLastError();
+        if ( result == WAIT_TIMEOUT )
+            result = WAIT_IO_COMPLETION;
+#endif
     }
     while (result == WAIT_IO_COMPLETION);
 
-    ResetEvent (p_condvar->handle);
+#ifndef VLC_WINSTORE_APP
+    ResetEvent(p_condvar->handle);
+#endif
 }
 
 int vlc_cond_timedwait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                         mtime_t deadline)
 {
     DWORD result;
+    DWORD delay;
 
     do
     {
@@ -290,14 +318,27 @@ int vlc_cond_timedwait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
         if( total < 0 )
             total = 0;
 
-        DWORD delay = (total > 0x7fffffff) ? 0x7fffffff : total;
-        vlc_mutex_unlock (p_mutex);
+        delay = (total > 0x7fffffff) ? 0x7fffffff : total;
+#ifndef VLC_WINSTORE_APP
+        vlc_mutex_unlock(p_mutex);
         result = vlc_WaitForSingleObject (p_condvar->handle, delay);
         vlc_mutex_lock (p_mutex);
     }
     while (result == WAIT_IO_COMPLETION);
 
     ResetEvent (p_condvar->handle);
+#else
+        DWORD new_delay = 50;
+        if (new_delay > delay)
+            new_delay = delay;
+        if (SleepConditionVariableCS(&p_condvar->cond, &p_mutex->mutex, new_delay))
+            return 0;
+        if (deadline != INFINITE)
+            delay -= new_delay;
+        result = GetLastError();
+    }
+    while (delay);
+#endif
 
     return (result == WAIT_OBJECT_0) ? 0 : ETIMEDOUT;
 }
-- 
2.2.0

