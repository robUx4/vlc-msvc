From 5e03d2d2f2f7b5c2e51531663543b5aa346632f8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Hugo=20Beauz=C3=A9e-Luyssen?= <hugo@beauzee.fr>
Date: Tue, 28 Apr 2015 12:09:42 +0200
Subject: [PATCH 074/128] taglib: Use an IOStream instead of a file path

---
 modules/meta_engine/taglib.cpp | 120 ++++++++++++++++++++++++++++++++++++++---
 1 file changed, 114 insertions(+), 6 deletions(-)

diff --git a/modules/meta_engine/taglib.cpp b/modules/meta_engine/taglib.cpp
index e6aab0a..7558e1d 100644
--- a/modules/meta_engine/taglib.cpp
+++ b/modules/meta_engine/taglib.cpp
@@ -59,6 +59,7 @@
 #include <fileref.h>
 #include <tag.h>
 #include <tbytevector.h>
+#include <tiostream.h>
 
 #if TAGLIB_VERSION >= VERSION_INT(1,7,0)
 # define TAGLIB_HAVE_APEFILE_H
@@ -114,6 +115,105 @@ vlc_module_end ()
 
 using namespace TagLib;
 
+class VlcIostream : public IOStream
+{
+public:
+    VlcIostream(demux_t* p_demux)
+        :  m_demux( p_demux )
+    {
+        vlc_object_hold( m_demux );
+        m_previousPos = stream_Tell( m_demux->s );
+    }
+
+    ~VlcIostream()
+    {
+        stream_Seek( m_demux->s, m_previousPos );
+        vlc_object_release( m_demux );
+    }
+
+    FileName name() const
+    {
+        return m_demux->psz_location;
+    }
+
+    ByteVector readBlock(ulong length)
+    {
+        ByteVector res(length, 0);
+        int i_read = stream_Read( m_demux->s, res.data(), length);
+        if (i_read < 0)
+            return ByteVector::null;;
+        res.resize(i_read);
+        return res;
+    }
+
+    void writeBlock(const ByteVector& data)
+    {
+        // Let's stay Read-Only for now
+        return;
+    }
+
+    void insert(const ByteVector& data, ulong start, ulong replace)
+    {
+        return;
+    }
+
+    void removeBlock(ulong start, ulong length)
+    {
+        return;
+    }
+
+    bool readOnly() const
+    {
+        return true;
+    }
+
+    bool isOpen() const
+    {
+        return true;
+    }
+
+    void seek(long offset, Position p)
+    {
+        uint64_t pos = 0;
+        switch (p)
+        {
+            case Current:
+                pos = stream_Tell( m_demux->s );
+                break;
+            case End:
+                pos = stream_Size( m_demux->s );
+                break;
+            default:
+                break;
+        }
+        stream_Seek( m_demux->s, pos + offset );
+    }
+
+    void clear()
+    {
+        return;
+    }
+
+    long tell() const
+    {
+        return stream_Tell( m_demux->s );
+    }
+
+    long length()
+    {
+        return stream_Size( m_demux->s );
+    }
+
+    void truncate(long length)
+    {
+        return;
+    }
+
+private:
+    demux_t* m_demux;
+    int64_t m_previousPos;
+};
+
 static void ExtractTrackNumberValues( vlc_meta_t* p_meta, const char *psz_value )
 {
     unsigned int i_trknum, i_trktot;
@@ -669,18 +769,25 @@ static int ReadMeta( vlc_object_t* p_this)
 {
     vlc_mutex_locker locker (&taglib_lock);
     demux_meta_t*   p_demux_meta = (demux_meta_t *)p_this;
-    demux_t*        p_demux = p_demux_meta->p_demux;
     vlc_meta_t*     p_meta;
-    FileRef f;
 
     p_demux_meta->p_meta = NULL;
-    if( strcmp( p_demux->psz_access, "file" ) )
-        return VLC_EGENERIC;
 
-    char *psz_path = strdup( p_demux->psz_file );
-    if( !psz_path )
+#if VLC_WINSTORE_APP
+    VlcIostream s( (demux_t*) p_demux_meta->p_parent );
+    FileRef f( &s );
+#else /* VLC_WINSTORE_APP */
+    FileRef f;
+
+    char *psz_uri = input_item_GetURI( p_demux_meta->p_item );
+    if( unlikely(psz_uri == NULL) )
         return VLC_ENOMEM;
 
+    char *psz_path = make_path( psz_uri );
+    free( psz_uri );
+    if( psz_path == NULL )
+        return VLC_EGENERIC;
+
 #if defined(_WIN32)
     wchar_t *wpath = ToWide( psz_path );
     if( wpath == NULL )
@@ -694,6 +801,7 @@ static int ReadMeta( vlc_object_t* p_this)
     f = FileRef( psz_path );
 #endif
     free( psz_path );
+#endif /* VLC_WINSTORE_APP */
 
     if( f.isNull() )
         return VLC_EGENERIC;
-- 
1.9.5.msysgit.1

